# This script is derived from the BPMN Modelling section (Section 5) of the provided "Testing Pipeline.ipynb" file. 
import json
from collections import defaultdict

try:
    from graphviz import Digraph  # type: ignore[import]
except ImportError as e:
    raise ImportError(
        "The 'graphviz' Python package is required for BPMN visualization."
    ) from e

try:
    from IPython.display import Image, display  # type: ignore[import]
except ImportError:
    Image = None
    def display(_obj):
        pass

def visualize_extracted_bpmn(json_data):
    """
    Transforms JSON into a visual BPMN graph with strictly vertically stacked swimlanes.
    """
    dot = Digraph('BPMN Diagram', 
                  graph_attr={
                      'rankdir': 'LR',      
                      'nodesep': '0.3', 
                      'ranksep': '1.0',
                      'compound': 'true',   
                      'fontname': 'Arial',
                      'splines': 'ortho',   # Orthogonal connectors
                      'pack': 'true',       # Forces tight grouping
                      'packmode': 'node',
                  })

    tasks = json_data.get('tasks', [])
    flows = json_data.get('sequence_flows', [])
    
    lanes = defaultdict(list)
    for task in tasks:
        actor = task.get('actor', 'Unknown')
        lanes[actor].append(task)

    # To ensure vertical ordering of lanes, we keep track of the first node in each lane
    lane_first_nodes = []

    # 3. Create Subgraphs (Lanes)
    for i, (actor, actor_tasks) in enumerate(lanes.items()):
        with dot.subgraph(name=f'cluster_{i}') as c:
            c.attr(label=f" {actor.upper()} ", 
                   labeljust='l',      
                   labelloc='t',       
                   style='solid',      
                   color='#666666',    
                   fontname='Arial-Bold',
                   fontsize='12')
            
            for j, task in enumerate(actor_tasks):
                # Standard BPMN Node
                c.node(
                    task['id'], 
                    label=f"<<B>{task['name']}</B>>", 
                    shape='box', 
                    style='rounded,filled', 
                    fillcolor='#E3F2FD', 
                    color='#1976D2'
                )
                # Save the first node of each lane to anchor the vertical order
                if j == 0:
                    lane_first_nodes.append(task['id'])

    # 4. Vertical Anchor Logic
    # We create invisible edges between the first node of each lane 
    # to force them to stack on top of each other.
    for i in range(len(lane_first_nodes) - 1):
        dot.edge(lane_first_nodes[i], lane_first_nodes[i+1], style='invis', weight='10')

    # 5. Add Actual Sequence Flows
    for flow in flows:
        dot.edge(flow['from'], flow['to'], penwidth='1.5', color='#333333')

    # 6. Render and Display
    try:
        png_data = dot.pipe(format='png')
        if Image:
            display(Image(png_data))
        else:
            print("Graph generated successfully.")
    except Exception as e:
        print(f"Error rendering graph: {e}")

    return dot

# Hier moet nog file path aangepast worden naar gecreÃ«erde json files door andere pipelines
# nu manuele file door running issues
data = json.load(open('/Users/julesnuytten/Desktop/Thesis/Master-Thesis/temporary_json_outputs/case_1_model_extracted_bpmn.json'))
visualize_extracted_bpmn(data)

data2 = json.load(open('/Users/julesnuytten/Desktop/Thesis/Master-Thesis/temporary_json_outputs/case_2_model_extracted_bpmn.json'))
visualize_extracted_bpmn(data2)