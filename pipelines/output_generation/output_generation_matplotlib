import json
import matplotlib.pyplot as plt
import matplotlib.patches as patches

def visualize_extracted_bpmn(json_data):
    tasks = json_data.get('tasks', [])
    flows = json_data.get('sequence_flows', [])
    
    # 1. Group tasks by actor to determine lane requirements
    actor_map = {}
    for task in tasks:
        actor = task.get('actor', 'Unknown')
        if actor not in actor_map:
            actor_map[actor] = []
        actor_map[actor].append(task)
    
    actors = list(actor_map.keys())
    num_lanes = len(actors)
    
    # Define grid constants
    lane_height = 2
    lane_width = 10
    task_width = 1.8
    task_height = 0.8
    
    fig, ax = plt.subplots(figsize=(12, num_lanes * 2))
    ax.set_xlim(0, lane_width)
    ax.set_ylim(0, num_lanes * lane_height)
    
    # Dictionary to store task coordinates for drawing arrows later
    coords = {}

    # 2. Draw the Lanes (The Pool)
    for i, actor in enumerate(reversed(actors)):
        y_bottom = i * lane_height
        
        # Draw Lane Rectangle
        lane_rect = patches.Rectangle((0, y_bottom), lane_width, lane_height, 
                                     linewidth=1.5, edgecolor='black', facecolor='none')
        ax.add_patch(lane_rect)
        
        # Draw Lane Header (Actor Name)
        ax.text(0.2, y_bottom + lane_height/2, actor.upper(), 
                weight='bold', rotation=90, va='center', ha='center', fontsize=10)
        ax.axvline(x=0.5, ymin=y_bottom/(num_lanes*lane_height), 
                   ymax=(y_bottom+lane_height)/(num_lanes*lane_height), color='black', lw=1.5)

        # 3. Place Tasks in the correct lane
        # Horizontal spacing based on task index across the whole process
        for task in tasks:
            if task.get('actor') == actor:
                # Find the global index of the task to determine X position
                task_index = tasks.index(task)
                x_pos = 1.5 + (task_index * (lane_width - 2) / len(tasks))
                y_pos = y_bottom + (lane_height / 2) - (task_height / 2)
                
                # Draw Task Box
                task_rect = patches.Rectangle((x_pos, y_pos), task_width, task_height, 
                                            linewidth=1, edgecolor='#1976D2', 
                                            facecolor='#E3F2FD', rx=0.1)
                ax.add_patch(task_rect)
                
                # Add Task Label
                ax.text(x_pos + task_width/2, y_pos + task_height/2, task['name'].replace(' ', '\n'), 
                        ha='center', va='center', fontsize=9, wrap=True)
                
                # Store center point for arrows
                coords[task['id']] = (x_pos + task_width, y_pos + task_height/2, x_pos, y_pos + task_height/2)

    # 4. Draw Sequence Flows (Arrows)
    for flow in flows:
        start_task = coords.get(flow['from'])
        end_task = coords.get(flow['to'])
        
        if start_task and end_task:
            # Draw arrow from right side of 'from' to left side of 'to'
            ax.annotate("", xy=(end_task[2], end_task[3]), xytext=(start_task[0], start_task[1]),
                        arrowprops=dict(arrowstyle="->", lw=1.5, color='#333333', 
                        connectionstyle="angle,angleA=0,angleB=90,rad=0"))

    ax.set_axis_off()
    plt.tight_layout()
    plt.show()

# Execution
data = json.load(open('/Users/julesnuytten/Desktop/Thesis/Master-Thesis/case_2_model_extracted_bpmn.json'))
visualize_extracted_bpmn(data)