import json
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from collections import defaultdict

def visualize_extracted_bpmn(json_data):
    """
    Renders a BPMN diagram using a fixed coordinate grid.
    Ensures lanes are perfectly aligned, stacked, and formatted.
    """
    tasks = json_data.get('tasks', [])
    flows = json_data.get('sequence_flows', [])
    
    # 1. Group tasks by actor
    lanes_data = defaultdict(list)
    for task in tasks:
        actor = task.get('actor', 'Unknown')
        lanes_data[actor].append(task)
    
    actors = list(lanes_data.keys())
    num_lanes = len(actors)
    
    # Grid Constants for professional BPMN look
    lane_h = 2.0
    pool_w = 16.0  # Increased width for better spacing
    header_w = 1.2  
    task_w, task_h = 2.4, 0.9
    
    fig, ax = plt.subplots(figsize=(14, num_lanes * 2.5))
    ax.set_xlim(0, pool_w)
    ax.set_ylim(0, num_lanes * lane_h)
    
    task_coords = {}

    # 2. Draw the Lanes (Stacked Rows)
    for i, actor in enumerate(reversed(actors)):
        y_offset = i * lane_h
        
        # Draw the Lane Boundary (Strictly aligned at x=0)
        lane_rect = patches.Rectangle((0, y_offset), pool_w, lane_h, 
                                     linewidth=2, edgecolor='black', facecolor='none')
        ax.add_patch(lane_rect)
        
        # Draw the Actor Header (Gray vertical bar on the left)
        header_rect = patches.Rectangle((0, y_offset), header_w, lane_h, 
                                       linewidth=2, edgecolor='black', facecolor='#E0E0E0')
        ax.add_patch(header_rect)
        
        # Add Actor Name in the Header (Rotated)
        ax.text(header_w/2, y_offset + lane_h/2, actor.upper(), 
                weight='bold', rotation=90, va='center', ha='center', fontsize=10)

        # 3. Place Tasks inside this lane
        for task in tasks:
            if task.get('actor') == actor:
                global_idx = tasks.index(task)
                # Spread tasks horizontally based on process order
                x_center = header_w + 2.0 + (global_idx * (pool_w - header_w - 4) / max(1, len(tasks)-1))
                
                # Draw Task Box (Using FancyBboxPatch for rounded corners compatibility)
                x_left = x_center - (task_w / 2)
                y_center = y_offset + (lane_h / 2)
                
                # Using boxstyle instead of rx for broader compatibility
                rect = patches.FancyBboxPatch(
                    (x_left, y_center - task_h/2), task_w, task_h,
                    boxstyle="round,pad=0.1",
                    linewidth=1.5, edgecolor='#1976D2', 
                    facecolor='#E3F2FD', zorder=3
                )
                ax.add_patch(rect)
                
                # Task Text
                ax.text(x_center, y_center, task['name'].replace(' ', '\n'), 
                        ha='center', va='center', fontsize=9, zorder=4)
                
                # Store coordinates for arrows
                task_coords[task['id']] = {
                    'right': (x_left + task_w + 0.1, y_center),
                    'left': (x_left - 0.1, y_center)
                }

    # 4. Draw Sequence Flows (Orthogonal Elbows)
    for flow in flows:
        start = task_coords.get(flow['from'])
        end = task_coords.get(flow['to'])
        
        if start and end:
            # Square corners: angleA=0 (horizontal out), angleB=90 (vertical in)
            ax.annotate("", xy=end['left'], xytext=start['right'],
                        arrowprops=dict(arrowstyle="-|>", color='#333333', lw=1.5,
                        connectionstyle="angle,angleA=0,angleB=90,rad=0"), zorder=2)

    ax.set_axis